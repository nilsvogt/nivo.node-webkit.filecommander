<!--
	NOTE:
	directory[n] = some/path/that/also/could/be/a/symlink
	cache[some/path/that/also/could/be/a/symlink].custom_path contains the resolved symlinkpath
	
	Todo:
	- flexbox
	- searchable cache

	Done:
	- sorted resultList
-->
<!DOCTYPE html>
<html ng-app="app">
	<head>

		<title>nivo</title>
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
		<link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
		<style type="text/css">
			/* reset */
			* { 
				margin: 0; padding: 0; outl_ine: 1px dashed blue;
			}
			*, *:before, *:after { 
				box-sizing: border-box; 
			}
			*:focus { outline: none; }
			
			/*scrollbar*/
			*::-webkit-scrollbar-corner {
				background-color: transparent;
			}
			*::-webkit-scrollbar {
				width: 9px; height: 9px;
			}

			*::-webkit-scrollbar-thumb {
				background-color: rgba(0,0,0,0.2); -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
			}

			/* generals */
			html, body { 
				height: 100%; font-size: 1px;
			}
			body {
				font-family: 'Roboto', sans-serif; background: #f3f3f3;
				font-size: 16rem;
			}
			a { text-decoration: none; }

		</style>
	</head>

	<body ng-controller="AppCtrl">
		<finder-view ng-repeat="finderId in finderInstances" finderview-instance-id="finderId"></finder-view>

		<script src="node_modules/angular/angular.min.js"></script>
		<script> "use strict";
			const node_os = require('os');
			const node_fs = require('fs');
			const node_path = require('path');
			const DS = node_path.sep;
			const node_child_process = require('child_process');

			var cache = {};

			var app = angular.module('app', []);

			app.directive('finderView', [()=>{
				
				/**
				 * Those styles get appended to the head only once
				 */
				var styles = `
					<style id="finderViewStyles">
						.finderview { float: left; width: 50%; out_line: 1px solid black; height: 100%; }
						.finderview > ul { height: calc(100% - 65rem - 30rem); overflow-y: scroll; ove_rflow-x: hidden; padding: 10rem 0; }
						.finderview > ul li { white-space: nowrap; text-overflow: ellipsis; width: 100%; overflow: hidden; }
						.finderview > ul li a { display: block; padding: 0 10rem; }
						.finderview > ul li a:hover,
						.finderview > ul li a:focus { background: rgba(0,0,0,0.2); }
					
						.finderview > div:first-child { height: 65rem; overflow: hidden; text-overflow: ellipsis; }
						.finderview > div:last-child  { height: 30rem; overflow: hidden; text-overflow: ellipsis; }
						
						.finderview > div:first-child [ng-model="querystring"] { display: block; width: 100%; height: 34rem; padding: 6rem 12rem; font-size: 14rem; line-height: 1.42857143; color: #555; background-color: #fff; border: 1px solid #ccc; bord_er-radius: 4px; box-shadow: inset 0 1px 1px rgba(0,0,0,.075);}

						.finderview > div:last-child { background: #222228; color: #EB5424; padding: 5rem; }

						.finderview__item--isDirectory { color: #555; }
						.finderview__item--isFile { color: green; }
						.finderview__item--isSymbolicLink { color: red; }


					</style>`;

				/**
				 * Template for every instance of finderView directive
				 */
				var template = `
					<section class="finderview">
						<div>
							<form ng-submit="enter()">
								<span style="display: inline-block; padding: 5px;">{{directory_path}}</span>
								<input type="text" ng-model="querystring" />
							</form>	
						</div>
						<ul>
							<li><a href="#" ng-click="openParentDir()">..</a></li>
							<li ng-repeat="node in viewResultList | filter:querystring">
								<a href="#" ng-click="open(node)" title="{{node}}" ng-class="{'finderview__item--isFile' : cache[node].isFile(), 'finderview__item--isDirectory' : cache[node].isDirectory(), 'finderview__item--isSymbolicLink' :cache[node].isSymbolicLink()}">
									<i class="fa fa-folder-o" ng-If="cache[node].isDirectory()"></i>
									{{basename(node)}} 
									<span ng-If="node !== cache[node].custom_realPath" style="font-size: 0.7em; ">({{cache[node].custom_realPath}})</span>
								</a>
							</li>
						</ul>
						<div>
							{{directory_path}}
						</div>
					</section>`;

				return {
					scope:{
			          finderviewInstanceId: "=" // unique id for the localStorage
			        },
					//replace: true,
					template: template,
					controller: function($scope, $element){

						var 
							directory = [], // contains a list of fullpaths for the directory recently read 
							$input = $element[0].querySelector('[ng-model="querystring"]'); // userinput-field for the querystring we utilize to filter the output

						$scope.cache = cache; // containing all nodeInfos of the collected paths 
						$scope.viewResultList = []; // the list of results presented in the view
						$scope.directory_path = null; // the current directory path of the directory at hand

						$scope.$watch('querystring', onQuerystringChange); // kommt noch in die link-methode

						// initially present recent directory OR rootdir
						_readDir(_storage('directory_path') || node_path.resolve(DS), (path)=>{
							document.title = path;
							_updateResult(directory);
							_resetQueryString();
						});

						// NOT YET IN USE
						function onQuerystringChange(new_value){
							if(!new_value) return;

							if(new_value[0] === '?'){
								$scope.viewResultList = cache;
							}else{
								$scope.viewResultList = directory;
							}
						}

						/**
						 * Obtain fylesystem info for a node passed a fullpath for
						 * @param string fullpath The fullpath of the node we want acquire info from
						 * @return false|object Return false if file is not accessable or an object containing status info
						 */
						function _getNodeFromFilesystem(fullpath){
							var nodeInfo;
							try{
								nodeInfo = node_fs.lstatSync(fullpath); // some files are not accessible since they are provided by the underlaying OS
							}catch($err){
								return false;
							}

							var realPath = node_path.normalize(node_fs.realpathSync(fullpath));
							
							nodeInfo.custom_realPath = realPath;
							nodeInfo.custom_path = fullpath;

							if(realPath != fullpath){
								return _getNodeFromFilesystem(realPath);
							}
							return nodeInfo;
						}

						/**
						 * Return the last portion of a path. Similar to the Unix basename command.
						 */
						$scope.basename = function(path){
							return node_path.basename(path);
						}

						/**
						 * The passed nodename prepended by the corresponding (current) directory path
						 */
						function _fullpath(node){
							return node_path.join($scope.directory_path, node);
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// VIEWS RESULT-LIST
						////////////////////////////////////////////////////////////////////////////////////

						function _updateResult(resultList){
							$scope.viewResultList = _sortResultList(resultList);
							$scope.$apply();
						}

						/**
						 * Sort either by name or type - how can we do both at the same time?
						 */
						function _sortResultList(resultList){

							/*
							resultList = resultList.sort(function (a, b) {
								return a.toLowerCase().localeCompare(b.toLowerCase());
							});
							/*/
							resultList = resultList.sort(function(a, b){
								var 
									a_sort = (cache[a].isDirectory() ? 'DIR' : 'FILE') + a,
									b_sort = (cache[b].isDirectory() ? 'DIR' : 'FILE') + b,
									comparison = a_sort.toLowerCase().localeCompare(b_sort.toLowerCase());
								if(comparison === 0){
									comparison = a_sort.localeCompare(b_sort);
								}
								return comparison;
								
							});
							//*/

							return resultList;
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// QUERY-INPUT FIELD
						////////////////////////////////////////////////////////////////////////////////////

						function _resetQueryString(){
							$scope.querystring = "";
							$scope.$apply();
						}

						/**
						 * 
						 */
						function _focusInput(){
							 $input.focus();
						}
						
						$scope.onFocusInput = function(){
							document.title = $scope.directory_path;
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// USER NAVIGATION ACTIONS
						////////////////////////////////////////////////////////////////////////////////////

						/**
						 * 
						 */
						$scope.open = function( path ){
							var node_info = _cacheGet(path);
							if(node_info.isDirectory()){
								_readDir(node_info.custom_path, (path)=>{
									document.title = path;
									_updateResult(directory);
									_resetQueryString();
								});
							}else if(node_info.isFile()){
								const child = node_child_process.exec(path, (error, stdout, stderr) => {
									if (error) {
										throw error;
									}
								});
							}
							
							_focusInput();
						}

						$scope.enter = function(){
							console.log('enter')
						}

						$scope.focusNextNode = function(){
							var 
								nodes = [].slice.call($element[0].querySelector('ul').children),
								focuesdNode = $element[0].querySelector('ul li a:focus').parentElement,
								index = nodes.indexOf(focuesdNode),
								index_next = index+1, // remember that nth-child begins to count at 1
								nextNode = $element[0].querySelector('ul li:nth-child('+ (index_next%nodes.length+1) +') a');
							nextNode.focus();
						}

						$scope.focusPreviousNode = function(){
							var 
								nodes = [].slice.call($element[0].querySelector('ul').children),
								focuesdNode = $element[0].querySelector('ul li a:focus').parentElement,
								index = nodes.indexOf(focuesdNode),
								index_next = (((index-1)%nodes.length)+nodes.length)%nodes.length, // negative modulo: ((number%n)+n)%n;
								nextNode = $element[0].querySelector('ul li:nth-child('+ (index_next+1) +') a');
							nextNode.focus();
						}

						/**
						 * Open parent directory of current directory
						 */
						$scope.openParentDir = function(){
							var isRootDir = $scope.directory_path === DS;
							if(isRootDir) return;

							var path = node_path.resolve($scope.directory_path, '../');
							_readDir(path, (path)=>{
								document.title = path;
								_updateResult(directory);
								_resetQueryString();
							});
							
							_focusInput();
						}

						/**
						 * Read passed directory and updates views resultList
						 * @param string path The path of the directory to be read
						 * @return void
						 */
						function _readDir(path, callback){
							callback = callback || function(){};

							$scope.directory_path = path;

							node_fs.readdir($scope.directory_path, (err, data) => {
								if (err){

									console.error(path, err);
									return;
								};
								
								_storage('directory_path', path); // remember last directorypath to get there on restart
								
								

								// create list of all nodes in the directory
								directory = [];
								data.forEach((basename) => {
									directory.push(_fullpath(basename));
								});

								// filter directory and update cache
								directory = directory.filter((fullpath) => {
									var nodeInfo = _getNodeFromFilesystem(fullpath);
									if(nodeInfo === false){
										return false;
									}

									// if(fullpath === 'C:\\Users\\All Users'){
									// 	console.log(nodeInfo, nodeInfo.isDirectory())
									// }
									_cacheSet(fullpath, nodeInfo);
									
									return true;
								});

								callback(path);
							});
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// CACHE
						////////////////////////////////////////////////////////////////////////////////////
						
						function _cacheSet(fullpath, nodeInfo){
							cache[fullpath] = nodeInfo;
						}

						function _cacheGet(path){
							return cache[path];
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// STORAGE
						////////////////////////////////////////////////////////////////////////////////////

						/**
						 * Get/Set a value in the storage by the respected namespace ('finderView-n')
						 * @return mixed
						 */
						function _storage(){
							var 
								key = 'finderView-' + $scope.finderviewInstanceId +'_'+ arguments[0],
								value = arguments[1];

							if(value === undefined){
								return localStorage.getItem(key);
							}else {
								return localStorage.setItem(key, value);
							}
						}

					},
					link: function(scope, element){
						var $input = element[0].querySelector('[ng-model="querystring"]');

						$input.addEventListener('focus', scope.onFocusInput);

						element[0].addEventListener('keydown', function(e){
							if(e.keyCode === 38){ // up
								e.preventDefault(); // prevent from triggering scrolling the scrollbar
								scope.focusPreviousNode();
							}else if(e.keyCode === 40){ // down
								e.preventDefault(); // prevent from triggering scrolling the scrollbar
								scope.focusNextNode();
							}
						})

						if(document.querySelector('#finderViewStyles') === null){
							document.head.insertAdjacentHTML( 'beforeend', styles );
						}
					}
				};
			}]);

			/**
			 * Querystring filter matches all nodes ignoring querystringdirectives
			 * @param  node
			 * @return bool
			 */
			app.filter('filterByQuerystring', function() {
				return function(val, querystring) {
					querystring = querystring.indexOf('?') === 0 ? querystring.substr(1) : querystring;
					return val.indexOf(querystring) > -1;
				};
			});

			app.controller('AppCtrl', function ($scope) {
				/*
				$scope.finderInstances = [1];
				/*/
				$scope.finderInstances = [1, 2];
				//*/
			});
		</script>
	</body>
</html>