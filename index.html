<!--
	NOTE:
	directory[n] = some/path/that/also/could/be/a/symlink
	cache[some/path/that/also/could/be/a/symlink].custom_path contains the resolved symlinkpath

	Todo:
	- searchable cache
	- command router middleware
		- :shell [open cwd in terminal]
			- create mappings for features
	- [strg+TAB] => focus next findervier [shift+strg+TAB] => focus prev findervier

	In Progress:
	- Context menu

	Done:
	- sorted resultList
	- flexbox
	- submit querystring should execute first result in filtered resultlist
-->
<!DOCTYPE html>
<html ng-app="app">
	<head>
		<title>nivo</title>
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css">
		<link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
		<style type="text/css">
			/* reset */
			* {
				margin: 0; padding: 0; outl_ine: 1px dashed blue;
			}
			*, *:before, *:after {
				box-sizing: border-box;
			}
			*:focus { outline: none; }

			/*scrollbar*/
			*::-webkit-scrollbar-corner {
				background-color: transparent;
			}
			*::-webkit-scrollbar {
				width: 5px; height: 9px;
			}

			*::-webkit-scrollbar-thumb {
				background-color: rgba(0,0,0,0.2); -webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
			}

			/* generals */
			html, body {
				height: 100%; font-size: 1px;
			}
			body {
				font-family: 'Roboto', sans-serif; background: #f3f3f3;
				font-size: 16rem;
			}
			a { text-decoration: none; }

			.collection-finderviews { height: 100%; display: flex; flex-direction: row;  }

			context-menu ul { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.2); }
			context-menu ul li { background: red; }
		</style>
	</head>

	<body ng-controller="AppCtrl">
		<div class="collection-finderviews">
			<finder-view class="finderview" ng-repeat="finderId in finderInstances" finderview-instance-id="finderId"></finder-view>

			<context-menu>
				<ul ng-show="menu">
					<li ng-repeat="node in menu" ng-click="perform(node.action)">{{node.name}}</li>
				</ul>
			</context-menu>
		</div>

		<script src="node_modules/angular/angular.min.js"></script>
		<script> "use strict";
			const node_os = require('os');
			const node_fs = require('fs');
			const node_path = require('path');
			const DS = node_path.sep;
			const node_child_process = require('child_process');

			var cache = {};

			var app = angular.module('app', []);

			////////////////////////////////////////////////////////////////////////////////////
			//// CONTEXT MENU
			////////////////////////////////////////////////////////////////////////////////////

			app.factory('contextMenuOpenShell', function(){
				var platform;

				function openInShell(directory){
					var cmd;

					// escape directory
					directory = directory.replace(/(["\s'$`\\])/g,'\\$1');

					if (platform === 'win32' || platform === 'win64') { // WIN
						cmd = "START cmd.exe /k cd "+directory;
					} else if (platform === 'darwin') { // OSX
						cmd = "open -a Terminal "+directory;
					} else if (platform === 'linux') { // LINUX
						cmd = "xterm -e 'cd "+directory+"'";
					}

					console.log(cmd);

					// invoke cmd
					node_child_process.exec(cmd);
				}

				return function(fullpath){
					var nodeInfo;
					try{
						nodeInfo = node_fs.lstatSync(fullpath); // some files are not accessible since they are provided by the underlaying OS
					}catch(err){
						console.error(err);
						return;
					}

					// we only want to open directories in a shell
					if(!nodeInfo.isDirectory()){
						console.info('You can not open other than directories in a shell');
						return;
					}

					var supported_os = ['win32', 'win64', 'darwin', 'linux'];

					platform = node_os.platform();

					if(supported_os.indexOf(platform) === -1){
						console.error('contextMenuOpenShell does not support platform '+platform);
						return;
					}

					return { name: 'Open in shell', action: openInShell};
				}
			});

			app.factory('contextMenuModel', function(contextMenuOpenShell){
				return function(path){
					return [contextMenuOpenShell(path)];
				}
			});

			app.directive('contextMenu', ()=>{
				return {
					controller: function($scope, $element, contextMenuModel){
						var path_current = null;
						/**
						 * Provides the menu to the view
						 * @param  string path The path we are about to present the contextmenu for
						 * @return void
						 */
						$scope.showMenu = function(path){
							path_current = path;
							var menu = contextMenuModel(path);
							if(menu.length === 0) return;

							$scope.menu = contextMenuModel(path);
							// TODO: set focus and handle tab on your own in order to not focus elements behind the context menu
						}

						$scope.closeMenu = function(){
							$scope.menu = null;
						}

						$scope.perform  = function(action){
							action.call(null, path_current);
							$scope.closeMenu();
						}
					},
					link: function(scope){
						document.addEventListener('keydown', function(e){
							if(e.ctrlKey && e.code === 'Enter'){
								e.preventDefault();

								var target = document.activeElement;
								if(target.classList.contains('finderview__item--isDirectory')){
									var path = target.title;
									scope.showMenu(path);
									scope.$apply();
								}
							}
						})
					}
				}
			});

			////////////////////////////////////////////////////////////////////////////////////
			//// FINDER VIEW
			////////////////////////////////////////////////////////////////////////////////////

			app.directive('finderView', [()=>{

				/**
				 * Those styles get appended to the head only once
				 */
				var styles = `
					<style id="finderViewStyles">
						.finderview { height: 100%; flex-grow: 1; width: 0; overflow: hidden;}
						.finderview > ul { height: calc(100% - 65rem - 30rem); overflow-y: scroll; hidden; padding: 10rem 0; border-left: 1px dashed #ccc; }
						.finderview > ul li { white-space: nowrap; text-overflow: ellipsis; width: 100%; overflow: hidden; }
						.finderview > ul li a { display: block; padding: 0 0 0 0; }
						.finderview > ul li a:hover { background: rgba(0,0,0,0.1); }
						.finderview > ul li a:focus { background: rgba(0,0,0,0.2); }
						.finderview > ul li a:before { content: attr(data-i); display: inline-block; font-size: 16rem; width: 2em; color: #999; bac_kground: #F0F2F1; text-align: right; }

						.finderview > div:first-child { position: relative; overflow: hidden; height: 65rem; }
						.finderview > div:first-child [ng-model="querystring"] { display: block; margin: 29rem 0 0 0; width: 100%; height: 34rem; padding: 6rem 12rem; font-size: 14rem; line-height: 1.42857143; color: #555; background-color: #fff; border: 1px solid #ccc; border-right: 0; box-shadow: inset 0 1px 1px rgba(0,0,0,.075); color: #EB5424 }
						.finderview > div:first-child span { position: absolute; min-width: 100%; top: 0; right: 0; display: block; padding: 9rem 12rem; height: 29rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 12rem; background: #222228; color: #EB5424;}

						.finderview > div:last-child  { height: 30rem; overflow: hidden; text-overflow: ellipsis;  padding: 5rem;}

						.finderview__item--isDirectory { color: #555; }
						.finderview__item--isFile { color: #0786C5; }
						.finderview__item--isFile:hover { color: #0786C5 }
						.finderview__item--isSymbolicLink { color: red; }
					</style>`;

				/**
				 * Template for every instance of finderView directive
				 */
				var template = `
						<div>
							<form ng-submit="submitSearch()">
								<span title="{{directory_path}}">{{directory_path}}</span>
								<input type="text" placeholder="What are you looking for?" ng-model="querystring" />
							</form>
						</div>
						<ul>
							<li><a href="#" ng-click="openParentDir()">..</a></li>
							<li ng-repeat="(i, node) in (filteredResults = (viewResultList | filterResults:querystring))">
								<a href="#" data-i="{{i}}" ng-click="open(node)" title="{{node}}" ng-class="{'finderview__item--isFile' : cache[node].isFile(), 'finderview__item--isDirectory' : cache[node].isDirectory(), 'finderview__item--isSymbolicLink' :cache[node].isSymbolicLink()}">
									<i class="fa fa-folder-o" ng-If="cache[node].isDirectory()"></i>
									{{basename(node)}}
									<span ng-If="node !== cache[node].custom_realPath" style="font-size: 0.7em; ">({{cache[node].custom_realPath}})</span>
								</a>
							</li>
						</ul>
						<div style="color: #555; font-size: 12rem; box-shadow: 0 0 3px rgba(0, 0, 0, 0.2); padding: 9rem">
							Matches: {{(viewResultList | filter:querystring).length}}
						</div>`;

				return {
					scope:{
								finderviewInstanceId: "=" // unique id for the localStorage
							},
					//replace: true,
					template: template,
					controller: function($scope, $element){
						var
							directory = [], // contains a list of fullpaths for the directory recently read
							$input = $element[0].querySelector('[ng-model="querystring"]'); // userinput-field for the querystring we utilize to filter the output

						$scope.cache = cache; // containing all nodeInfos of the collected paths
						$scope.viewResultList = []; // the list of results presented in the view
						$scope.directory_path = null; // the current directory path of the directory at hand

						$scope.$watch('querystring', onQuerystringChange); // kommt noch in die link-methode

						// initially present recent directory OR rootdir
						_readDir(_storage('directory_path') || node_path.resolve(DS), (path)=>{
							document.title = path;
							_updateResult(directory);
							_resetQueryString();
						});

						// NOT YET IN USE
						function onQuerystringChange(new_value){
							if(!new_value) return;

							if(new_value[0] === '?'){
								$scope.viewResultList = cache;
							}else{
								$scope.viewResultList = directory;
							}
						}

						/**
						 * Obtain fylesystem info for a node passed a fullpath for
						 * @param string fullpath The fullpath of the node we want acquire info from
						 * @return false|object Return false if file is not accessable or an object containing status info
						 */
						function _getNodeFromFilesystem(fullpath){
							var nodeInfo;
							try{
								nodeInfo = node_fs.lstatSync(fullpath); // some files are not accessible since they are provided by the underlaying OS
							}catch($err){
								return false;
							}

							var realPath = node_path.normalize(node_fs.realpathSync(fullpath));

							nodeInfo.custom_realPath = realPath;
							nodeInfo.custom_path = fullpath;

							if(realPath != fullpath){
								return _getNodeFromFilesystem(realPath);
							}
							return nodeInfo;
						}

						/**
						 * Return the last portion of a path. Similar to the Unix basename command.
						 */
						$scope.basename = function(path){
							return node_path.basename(path);
						}

						/**
						 * The passed nodename prepended by the corresponding (current) directory path
						 */
						function _fullpath(node){
							return node_path.join($scope.directory_path, node);
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// VIEWS RESULT-LIST
						////////////////////////////////////////////////////////////////////////////////////

						function _updateResult(resultList){
							$scope.viewResultList = _sortResultList(resultList);
							$scope.$apply();
						}

						/**
						 * Sort either by name or type - how can we do both at the same time?
						 */
						function _sortResultList(resultList){

							/*
							resultList = resultList.sort(function (a, b) {
								return a.toLowerCase().localeCompare(b.toLowerCase());
							});
							/*/
							resultList = resultList.sort(function(a, b){
								var
									a_sort = (cache[a].isDirectory() ? 'DIR' : 'FILE') + a,
									b_sort = (cache[b].isDirectory() ? 'DIR' : 'FILE') + b,
									comparison = a_sort.toLowerCase().localeCompare(b_sort.toLowerCase());
								if(comparison === 0){
									comparison = a_sort.localeCompare(b_sort);
								}
								return comparison;

							});
							//*/

							return resultList;
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// QUERY-INPUT FIELD
						////////////////////////////////////////////////////////////////////////////////////

						function _resetQueryString(){
							$scope.querystring = "";
							$scope.$apply();
						}

						/**
						 *
						 */
						$scope.focusInput = function(){
							 $input.focus();
						}

						$scope.onFocusInput = function(){
							document.title = $scope.directory_path;
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// USER NAVIGATION ACTIONS
						////////////////////////////////////////////////////////////////////////////////////

						/**
						 *
						 */
						$scope.open = function( path ){
							var node_info = _cacheGet(path);
							if(node_info.isDirectory()){
								_readDir(node_info.custom_path, (path)=>{
									document.title = path;
									_updateResult(directory);
									_resetQueryString();
								});
							}else if(node_info.isFile()){
								const child = node_child_process.exec(path, (error, stdout, stderr) => {
									if (error) {
										throw error;
									}
								});
							}

							$scope.focusInput();
						}

						$scope.openFocusedNode = function(){
							var
								nodes = [].slice.call($element[0].querySelector('ul').children),
								focusedNode = document.activeElement.parentElement,
								index = nodes.indexOf(focusedNode);

							// make sure focused element is an item in the list. Otherwise stop processing here.
							if(index === -1) return;

							$scope.open(document.activeElement.title);
						}

						$scope.submitSearch = function(){
							console.log('SUBMIT')

							if(!$scope.filteredResults.length) return;
							$scope.open($scope.filteredResults[0]);
						}

						$scope.focusNextNode = function(){
							var
								nodes = [].slice.call($element[0].querySelector('ul').children),
								focusedNode = document.activeElement.parentElement,
								index = nodes.indexOf(focusedNode),
								nextNode = $element[0].querySelector('ul li:first-child a'); // default next item is the first item

							if(index > -1){ // if focusedNode was found in nodecollection we can grab the next sibling otherwise we just focus the first element
								nextNode = $element[0].querySelector('ul li:nth-child('+ (((index+1)%nodes.length)+1) +') a');
							}

							nextNode.focus();
						}


						$scope.focusPreviousNode = function(){
							var
								nodes = [].slice.call($element[0].querySelector('ul').children),
								focuesdNode = $element[0].querySelector('ul li a:focus').parentElement,
								index = nodes.indexOf(focuesdNode),
								index_next = (((index-1)%nodes.length)+nodes.length)%nodes.length, // negative modulo: ((number%n)+n)%n;
								nextNode = $element[0].querySelector('ul li:nth-child('+ (index_next+1) +') a');
							nextNode.focus();
						}

						/**
						 * Open parent directory of current directory
						 */
						$scope.openParentDir = function(){
							var isRootDir = $scope.directory_path === DS;
							if(isRootDir) return;

							var path = node_path.resolve($scope.directory_path, '../');
							_readDir(path, (path)=>{
								document.title = path;
								_updateResult(directory);
								_resetQueryString();
							});

							$scope.focusInput();
						}

						/**
						 * Read passed directory and updates views resultList
						 * @param string path The path of the directory to be read
						 * @return void
						 */
						function _readDir(path, callback){
							callback = callback || function(){};

							$scope.directory_path = path;

							node_fs.readdir($scope.directory_path, (err, data) => {
								if (err){

									console.error(path, err);
									return;
								};

								_storage('directory_path', path); // remember last directorypath to get there on restart



								// create list of all nodes in the directory
								directory = [];
								data.forEach((basename) => {
									directory.push(_fullpath(basename));
								});

								// filter directory and update cache
								directory = directory.filter((fullpath) => {
									var nodeInfo = _getNodeFromFilesystem(fullpath);
									if(nodeInfo === false){
										return false;
									}

									// if(fullpath === 'C:\\Users\\All Users'){
									// 	console.log(nodeInfo, nodeInfo.isDirectory())
									// }
									_cacheSet(fullpath, nodeInfo);

									return true;
								});

								callback(path);
							});
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// CACHE
						////////////////////////////////////////////////////////////////////////////////////

						function _cacheSet(fullpath, nodeInfo){
							cache[fullpath] = nodeInfo;
						}

						function _cacheGet(path){
							return cache[path];
						}

						////////////////////////////////////////////////////////////////////////////////////
						//// STORAGE
						////////////////////////////////////////////////////////////////////////////////////

						/**
						 * Get/Set a value in the storage by the respected namespace ('finderView-n')
						 * @return mixed
						 */
						function _storage(){
							var
								key = 'finderView-' + $scope.finderviewInstanceId +'_'+ arguments[0],
								value = arguments[1];

							if(value === undefined){
								return localStorage.getItem(key);
							}else {
								return localStorage.setItem(key, value);
							}
						}

					},
					link: function(scope, element){
						var $input = element[0].querySelector('[ng-model="querystring"]');

						// handle focus of searchStringInput
						$input.addEventListener('focus', scope.onFocusInput);

						// handle [UP] and [DOWN] keys
						element[0].addEventListener('keydown', function(e){
							if(e.keyCode === 16) return; // shiftleft + shiftright
							if(e.code === 'Tab') return; // Tab is used natively
							if(e.code === 'Enter') return; // prevent form from being submitted (To be honest, I dont relly know why the form should get submitted but it does so when we not return here..)

							if(e.keyCode === 38){ // up
								e.preventDefault(); // prevent from triggering scrolling the scrollbar
								scope.focusPreviousNode();
							}else if(e.keyCode === 40){ // down
								e.preventDefault(); // prevent from triggering scrolling the scrollbar
								scope.focusNextNode();
							}else if(e.keyCode === 39){ // right
								scope.openFocusedNode();
							}else if(e.keyCode === 37){ // right
								scope.openParentDir();
							}else if(e.which !== 0 && !e.ctrlKey && !e.metaKey && !e.altKey){ // handle all printable characters
								console.log('RECEIVING input', e)
								scope.focusInput();
							}
						});

						// insert CSS only once
						if(document.querySelector('#finderViewStyles') === null){
							document.head.insertAdjacentHTML( 'beforeend', styles );
						}
					}
				};
			}]);

			app.filter('filterResults', function() {
				return function(items, querystring) {
					var filtered = [];

					for (var i = 0; i < items.length; i++) {
						var item = items[i];
						if (new RegExp('^.*'+querystring+'[^\\\\]*$', 'i').test(item)) {
							filtered.push(item);
						}
					}

					return filtered;
				};
			});

			app.controller('AppCtrl', function ($scope, $element) {
				// handle ctrl+1, ctrl+2, ctrl+3, ctrl+4 to update amount of finderViewInsatnces
				var gridKeys = [1,2,3,4];
				$element[0].addEventListener('keydown', function(e){
					if(e.ctrlKey && gridKeys.indexOf(parseInt(String.fromCharCode(e.keyCode))) !== -1){
						var numberInstances = parseInt(String.fromCharCode(e.keyCode), 10);
						showNumberFinderViews(numberInstances);
						$scope.$apply();
					}
				});

				/**
				 * Update $scope.finderInstances so view shows up desired amount of finderInstances
				 */
				function showNumberFinderViews (numberInstances){
					var range = [];
					for(var i = 1; i <= numberInstances; i++){
						range.push(i);
					}
					$scope.finderInstances = range;

					// remmeber that setting
					localStorage.setItem('AppCtrl_numberFinderInstances', numberInstances);
				}

				// show last amount of finderInstances
				showNumberFinderViews(localStorage.getItem('AppCtrl_numberFinderInstances') || 1);
			});
		</script>
	</body>
</html>